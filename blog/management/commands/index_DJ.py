#To run, go to folder containing manage.py with the following command: >python manage.py [script name]#Make a csv file of DJ tickers from most recent date and write them to database.from django.core.management.base import BaseCommand, CommandErrorimport csvimport requestsimport datetimeimport reimport randomimport timefrom blog.models import Index_DJclass Command(BaseCommand):	help = "Populates csv file for DJ index"	def handle(self, *args, **options):		today = str(datetime.date.today())		#print today		#DJlist = []		with open('index_DJ.csv', 'rb') as file:			infile = csv.reader(file, delimiter=",", quotechar='"')			LastDay = list(infile)[-1][0]  #Read the date for the most recent ticker entry.			#print LastDay, type(LastDay), today			if LastDay != today:  #Only append if today's tickers havn't already been entered into database.				with open('index_DJ.csv', 'ab') as file:  #Use 'ab' to append in binary mode (preventing line skip) to existing csv file.					#file = open('index_DJ.csv', 'wb')					outfile = csv.writer(file, delimiter=",", quotechar='"')					response = requests.get('https://query1.finance.yahoo.com/v10/finance/quoteSummary/%5EDJI?formatted=true&crumb=vPC4QPS8MCo&lang=en-US&region=US&modules=components&corsDomain=finance.yahoo.com')  #Get DJ list from Yahoo Finance.					html = response.text  #Converts page request to string variable.					#print html					DJsym = ""					for ch in html.split('"components":[')[1]:						if ch != "]":							DJsym += ch						else:							break #Continue adding character ('ch') to 'DJsym' until '"' is ran into.					#print DJsym					pattern = re.compile('"(.+?)"')  #'.+' represents one-or-more-character string while '?' at the end represents non-greedy retrieval.					DJlist = pattern.findall(DJsym)  #Find all pattern in DJsym and return them as a list. Note: no need to predefine (DJlist=[]).					DJlist.sort()  #list.sort() method modifies the list in-place and is slightly more efficient than sorted(list).					print DJlist					for tick in DJlist:						outfile.writerow([today, tick])			else:  #Don't append to csv file if last day in the file is the same as today.				pass		fields = ['Day', 'Symbol']  #Must match individual column names in models.py for entry into database.		#if DJlist:  #To avoid entering duplicate data, only enter into sql database if DJlist is neither empty nor null.		if Index_DJ.objects.exists():  #To avoid entering duplicate data, only enter into sql database if Index_DJ is neither empty nor null.			LastEntry = Index_DJ.objects.latest('Day')			#print LastEntry.Day, type(str(LastEntry.Day)), type(today)			if str(LastEntry.Day) != today:  #Even if there is already data in database, the latest entry must not be from today to avoid duplicate entry from local update.				with open('index_DJ.csv', 'rb') as file:  # May need to use absolute path when on Pythonanywhere server (i.e. use '/home/cqcum6er/my-first-blog/index_DJ.csv' as file path.)					infile = csv.reader(file, delimiter=",", quotechar='"')  #Specify csv item boundary.					#if Index_DJ.objects.exists():					LastRowDate = ""  #Reserve a variable for the date from last row .					#print type(LastRowDate)					for row in infile:  #Read csv file in reverse order or the most recent entry 1st for display on server; must convert csv reader object to list format 1st with list().						#print row						if row[0] == LastRowDate or LastRowDate == "":  #Keep write to database while the date is still the same as last entry.							Index_DJ.objects.create(**dict(zip(fields, row)))  #zip() combines two lists into one list of pairs of items from both lists (fields and row). dict() converts the list of pairs into a dictionary. (**{'key': 'value'}) is the equivalent of function(key='value').							LastRowDate = row[0]  #Mark the current date for comparison to the next date from the next row.						else:							break		else:			with open('index_DJ.csv', 'rb') as file:				infile = csv.reader(file, delimiter=",", quotechar='"')				for row in infile:					Index_DJ.objects.create(**dict(zip(fields, row)))